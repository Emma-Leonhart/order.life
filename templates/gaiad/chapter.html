{% extends "base.html" %}
{% block title %}{{ t.gaiad }} {{ chapter_num }} — {{ t.gaiad_index.title }}{% endblock %}
{% block meta_description %}{{ t.gaiad }} {{ t.chapter }} {{ chapter_num }}{% if chapter_month %} — {{ t.months[chapter_month.id] }} {{ chapter_day }}, {{ t.day_of_year }} {{ chapter_num }}{% endif %}. {{ t.gaiad_subtitle }}.{% endblock %}
{% block og_title %}{{ t.gaiad }}: {{ t.chapter }} {{ chapter_num }} — {{ t.site_title }}{% endblock %}
{% block og_description %}{% if chapter_month %}{{ t.months[chapter_month.id] }} {{ chapter_day }} · {{ t.day_of_year }} {{ chapter_num }}. {% endif %}{{ t.gaiad_subtitle }}.{% endblock %}
{% block twitter_title %}{{ t.gaiad }}: {{ t.chapter }} {{ chapter_num }} — {{ t.site_title }}{% endblock %}
{% block twitter_description %}{% if chapter_month %}{{ t.months[chapter_month.id] }} {{ chapter_day }} · {{ t.day_of_year }} {{ chapter_num }}. {% endif %}{{ t.gaiad_subtitle }}.{% endblock %}

{% block content %}
<div class="container">
  <div class="breadcrumb">
    <a href="{{ base }}/">{{ t.nav.home }}</a>
    <span>›</span>
    <a href="{{ base }}/gaiad/">{{ t.gaiad }}</a>
    <span>›</span>
    {{ t.chapter }} {{ chapter_num }}
  </div>

  <div class="chapter-content">
    <div class="chapter-header">
      <h1>{{ t.gaiad }}: {{ t.chapter }} {{ chapter_num }}</h1>
      {% if chapter_month %}
      <p class="chapter-meta">
        {{ chapter_month.symbol }}
        <a href="{{ base }}/calendar/{{ chapter_month.id }}/">{{ t.months[chapter_month.id] }}</a>
        <a href="{{ base }}/calendar/{{ chapter_month.id }}/{{ '%02d' % chapter_day }}/">{{ chapter_day }}</a>
        · {{ t.day_of_year }} {{ chapter_num }}
      </p>
      {% endif %}
    </div>

    {% if chapter_text %}
    <div class="chapter-text">{{ chapter_text }}</div>
    {% else %}
    <div class="text-center" style="padding: 60px 20px; color: var(--text-muted);">
      <p style="font-size: 1.2em;">{{ t.gaiad_index.coming_soon }}</p>
      <p style="margin-top: 10px;">{{ t.chapter }} {{ chapter_num }}</p>
    </div>
    {% endif %}

    {# ── Your Sacred Land — compact pill ──────────────────────────────── #}
    <div class="sl-widget">
      <a id="sl-pill" class="daily-reading-link" href="#" style="opacity:0.6;cursor:default;" aria-live="polite">Finding your sacred land…</a>
      <a id="sl-gps" href="#" style="display:none;font-size:0.75rem;color:var(--text-dim);text-decoration:none;" title="Use GPS for a more precise location">precise location</a>
    </div>

    <div class="chapter-nav">
      {% if prev_chapter %}
      <a href="{{ base }}/gaiad/{{ '%03d' % prev_chapter }}/">{{ t.prev }}: {{ prev_chapter }}</a>
      {% else %}<span></span>{% endif %}
      {% if next_chapter %}
      <a href="{{ base }}/gaiad/{{ '%03d' % next_chapter }}/">{{ t.next }}: {{ next_chapter }}</a>
      {% else %}<span></span>{% endif %}
    </div>
  </div>
</div>
{% endblock %}

{% block scripts %}
<script>
(function () {
  var pill = document.getElementById('sl-pill');
  var gpsLink = document.getElementById('sl-gps');
  var cachedRealms = null;
  var cachedCountry = null;

  // ── Point-in-polygon (ray casting). GeoJSON coords are [lon, lat]. ──
  function pipRing(lat, lon, ring) {
    var inside = false;
    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
      var rlat = ring[i][1], rlon = ring[i][0];
      var nlat = ring[j][1], nlon = ring[j][0];
      if (((rlat > lat) !== (nlat > lat)) &&
          (lon < (nlon - rlon) * (lat - rlat) / (nlat - rlat) + rlon)) {
        inside = !inside;
      }
    }
    return inside;
  }

  function pipGeom(lat, lon, geom) {
    if (!geom) return false;
    if (geom.type === 'Polygon') return pipRing(lat, lon, geom.coordinates[0]);
    if (geom.type === 'MultiPolygon') {
      return geom.coordinates.some(function (p) { return pipRing(lat, lon, p[0]); });
    }
    return false;
  }

  function pointInData(lat, lon, data) {
    if (!data) return false;
    if (data.type === 'FeatureCollection') {
      return (data.features || []).some(function (f) {
        return f && f.geometry && pipGeom(lat, lon, f.geometry);
      });
    }
    if (data.type === 'Feature') return data.geometry && pipGeom(lat, lon, data.geometry);
    return pipGeom(lat, lon, data);
  }

  function fetchGeoshape(realm) {
    var clean = realm.geoshape.replace(/^Data:/, '');
    var url = 'https://commons.wikimedia.org/w/api.php?action=jsondata&title=' +
      encodeURIComponent(clean) + '&formatversion=2&origin=*&format=json';
    return fetch(url)
      .then(function (r) { return r.json(); })
      .then(function (d) { return (d && d.jsondata && d.jsondata.data) ? d.jsondata.data : null; })
      .catch(function () { return null; });
  }

  // ── Display helpers ──
  function showFound(realm) {
    var slug = realm.slug || realm.qid;
    pill.textContent = realm.realm_name + ' · Read local fudoki →';
    pill.href = '/fudoki/' + slug + '/';
    pill.style.opacity = '1';
    pill.style.cursor = '';
    gpsLink.style.display = 'inline';
  }

  function showNotFound() {
    pill.textContent = 'Land not yet hallowed · browse all realms';
    pill.href = '/fudoki/';
    pill.style.opacity = '0.7';
    pill.style.cursor = '';
    gpsLink.style.display = 'inline';
  }

  function showError() {
    pill.textContent = '⊕ Find your sacred land';
    pill.style.opacity = '1';
    pill.style.cursor = 'pointer';
    pill.addEventListener('click', function (e) { e.preventDefault(); triggerGPS(); }, { once: true });
  }

  // ── Search through candidates in batches, stop on first match ──
  function searchCandidates(lat, lon, candidates) {
    var BATCH = 8, idx = 0, found = false;
    function nextBatch() {
      if (found || idx >= candidates.length) {
        if (!found) showNotFound();
        return;
      }
      var batch = candidates.slice(idx, idx + BATCH);
      idx += BATCH;
      Promise.all(batch.map(function (realm) {
        return fetchGeoshape(realm).then(function (data) {
          return (data && pointInData(lat, lon, data)) ? realm : null;
        });
      })).then(function (results) {
        if (found) return;
        var hit = results.find(function (r) { return r; });
        if (hit) { found = true; showFound(hit); } else { nextBatch(); }
      });
    }
    nextBatch();
  }

  function runWithCoords(lat, lon, realms) {
    var country = cachedCountry || '';
    var candidates = country
      ? realms.filter(function (r) { return r.country && r.country.toLowerCase() === country.toLowerCase(); })
      : realms;
    if (candidates.length === 0) { showNotFound(); return; }
    searchCandidates(lat, lon, candidates);
  }

  // ── GPS button ──
  function triggerGPS() {
    if (!navigator.geolocation) { showError(); return; }
    pill.textContent = 'Getting precise location…';
    pill.style.opacity = '0.6';
    pill.style.cursor = 'default';
    gpsLink.style.display = 'none';
    navigator.geolocation.getCurrentPosition(
      function (pos) {
        var lat = pos.coords.latitude, lon = pos.coords.longitude;
        if (cachedRealms) {
          runWithCoords(lat, lon, cachedRealms);
        } else {
          fetch('/static/realms-index.json')
            .then(function (r) { return r.json(); })
            .then(function (realms) { cachedRealms = realms; runWithCoords(lat, lon, realms); })
            .catch(function () { showNotFound(); });
        }
      },
      function () { pill.textContent = 'Location access denied.'; pill.style.opacity = '0.5'; }
    );
  }

  gpsLink.addEventListener('click', function (e) { e.preventDefault(); triggerGPS(); });

  // ── IP geolocation: try ipapi.co then ipwho.is as fallback ──
  function getIPLocation() {
    return fetch('https://ipapi.co/json/')
      .then(function (r) { return r.json(); })
      .then(function (d) {
        if (!d.latitude) throw new Error();
        return { lat: d.latitude, lon: d.longitude, country: d.country_name || '' };
      })
      .catch(function () {
        return fetch('https://ipwho.is/')
          .then(function (r) { return r.json(); })
          .then(function (d) {
            if (!d.latitude) throw new Error();
            return { lat: d.latitude, lon: d.longitude, country: d.country || '' };
          });
      });
  }

  // ── Boot: fetch realm index + IP location in parallel ──
  // Show GPS button immediately so there's always something to click.
  gpsLink.style.display = 'inline';

  Promise.all([
    fetch('/static/realms-index.json').then(function (r) { return r.json(); }),
    getIPLocation()
  ]).then(function (results) {
    cachedRealms = results[0];
    var geo = results[1];
    cachedCountry = geo.country;
    runWithCoords(geo.lat, geo.lon, cachedRealms);
  }).catch(function () { showError(); });
})();
</script>
{% endblock %}
